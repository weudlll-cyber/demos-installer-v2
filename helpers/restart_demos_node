#!/bin/bash
# restart_demos_node — node-first, safe restart flow with red messages
# - Mask unit to avoid flapping
# - Start node first
# - If node needs DB and DB not reachable: start DB only if host port free
# - Wait for DB TCP readiness, then probe node HTTP /health
# - Restore unit enablement state
# - Extra diagnostics printed at multiple points for troubleshooting
set -euo pipefail
IFS=$'\n\t'

UNIT="demos-node.service"
ENV="/opt/demos-node/.env"
NODE_PORT=53550
DB_PORT=5332
DB_WAIT=30    # seconds to wait for DB TCP after attempting to start DB
HTTP_WAIT=60  # seconds to wait for HTTP /health
DB_CONTAINER_NAME="postgres_5332"  # container name the node expects

# small helpers (all messages printed in red)
log(){ printf "\e[91m%s\e[0m\n" "$*"; }
err(){ printf "\e[91m%s\e[0m\n" "$*" >&2; }

# read NODE_PORT override if present
if [ -f "$ENV" ]; then
  p=$(grep -m1 '^NODE_PORT=' "$ENV" | cut -d= -f2 || true)
  [ -n "$p" ] && NODE_PORT="$p"
fi

# prefer docker-compose stop/start when we can detect the DB container publishing DB_PORT
detect_db_cid(){
  command -v docker >/dev/null 2>&1 || return 0
  docker ps --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' | awk -v p=":${DB_PORT}->" '$0 ~ p { print $1; exit }'
}

wait_tcp(){
  # wait for 127.0.0.1:$1 to accept TCP connections up to $2 seconds
  local port=$1 timeout=${2:-10} elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${port}" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1; elapsed=$((elapsed+1))
  done
  return 1
}

http_probe(){
  # probe loopback and return 0 on success
  local timeout=${1:-30} elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if curl -fsS -m 3 "http://127.0.0.1:${NODE_PORT}/health" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1; elapsed=$((elapsed+1))
  done
  return 1
}

docker_available(){
  command -v docker >/dev/null 2>&1
}

docker_container_exists(){
  local name="$1"
  docker_available || return 1
  docker ps -a --format '{{.Names}}' | grep -qx "$name"
}

docker_container_status(){
  local name="$1"
  docker_available || return 1
  docker inspect --format '{{.State.Status}}' "$name" 2>/dev/null || echo ""
}

docker_try_start(){
  local id="$1"
  sudo docker start "$id" >/dev/null 2>&1 || return 1
  return 0
}

docker_force_remove(){
  local name="$1"
  sudo docker rm -f "$name" >/dev/null 2>&1 || return 1
  return 0
}

# small diagnostic helper to print system and docker state
print_diagnostics(){
  log "=== DIAGNOSTICS BEGIN ==="
  log "Systemd unit status for ${UNIT}:"
  sudo systemctl status "${UNIT}" --no-pager -l || true
  log "Recent journal lines for ${UNIT}:"
  sudo journalctl -u "${UNIT}" --no-pager -n 80 || true
  if docker_available; then
    log "Docker: list all containers (ps -a):"
    sudo docker ps -a --format 'ID={{.ID}} Name={{.Names}} Status={{.Status}} Ports={{.Ports}}' || true
    if docker_container_exists "${DB_CONTAINER_NAME}"; then
      log "Docker: inspect ${DB_CONTAINER_NAME}:"
      sudo docker inspect --format 'Name: {{.Name}} ID: {{.Id}} State: {{.State.Status}} RestartCount: {{.RestartCount}}' "${DB_CONTAINER_NAME}" 2>/dev/null || true
      log "Docker: last 200 lines of ${DB_CONTAINER_NAME} logs:"
      sudo docker logs --tail 200 "${DB_CONTAINER_NAME}" || true
    else
      log "Docker: no container named ${DB_CONTAINER_NAME} found"
    fi
  else
    log "Docker not available on this host"
  fi
  log "=== DIAGNOSTICS END ==="
}

# BEGIN restart flow
log "Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true

# 1) Check whether host DB port is already bound. If bound, do NOT attempt to start DB later.
if ss -ltnp | grep -qE ":${DB_PORT}"; then
  log "Host port ${DB_PORT} is already bound — will NOT attempt to start DB container (to avoid conflicts)"
  SKIP_DB_START=1
else
  SKIP_DB_START=0
fi

# 2) Start the node service first (node-first policy)
log "Unmasking and starting ${UNIT} (node-first)"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
if ! sudo systemctl start "${UNIT}"; then
  err "systemctl start failed; printing diagnostics and aborting"
  print_diagnostics
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

# show immediate status after start attempt
log "systemctl status immediately after start attempt:"
sudo systemctl status "${UNIT}" --no-pager -l || true
log "tail of journal for ${UNIT} (last 40 lines):"
sudo journalctl -u "${UNIT}" --no-pager -n 40 || true

# 3) Wait for node HTTP /health briefly to see if node is already healthy
log "Waiting up to ${HTTP_WAIT}s for HTTP /health on port ${NODE_PORT}"
if http_probe "${HTTP_WAIT}"; then
  log "Node responded to /health — restore enablement and finish"
  if [ "${PRE_ENABLED}" -eq 1 ]; then
    log "Restoring enablement: enabling ${UNIT}"
    sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
  else
    log "Leaving ${UNIT} disabled (was disabled before)"
  fi
  log "Restart complete — node responsive"
  exit 0
fi

# 4) Node did not become healthy. Probe DB reachability now.
log "Node not healthy yet — checking DB reachability on 127.0.0.1:${DB_PORT}"
if wait_tcp "${DB_PORT}" 1; then
  log "DB already reachable on ${DB_PORT}; giving node a bit more time to become healthy"
  # give node a short grace period to become healthy
  if http_probe 15; then
    log "Node became healthy after DB was reachable"
    if [ "${PRE_ENABLED}" -eq 1 ]; then
      log "Restoring enablement: enabling ${UNIT}"
      sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
    fi
    exit 0
  fi
  err "Node still not healthy despite DB reachable; printing diagnostics and aborting"
  print_diagnostics
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

# 5) DB not reachable. If we previously detected host port bound, abort to avoid conflicts.
if [ "${SKIP_DB_START}" -eq 1 ]; then
  err "DB not reachable on ${DB_PORT} and host port ${DB_PORT} is in use. Aborting and leaving node masked for operator investigation."
  print_diagnostics
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 2
fi

# 5.5) Guard against container name conflicts while being conservative
if docker_available; then
  log "Detecting DB container publishing port: calling detect_db_cid()"
  CID=$(detect_db_cid || true)
  log "detect_db_cid returned: ${CID:-<none>}"

  if docker_container_exists "${DB_CONTAINER_NAME}"; then
    STATUS=$(docker_container_status "${DB_CONTAINER_NAME}" || true)
    log "Found container ${DB_CONTAINER_NAME} with status '${STATUS}'"
    if [ "$STATUS" = "running" ]; then
      log "${DB_CONTAINER_NAME} is running — will attempt to reuse it (no removal)"
      if wait_tcp "${DB_PORT}" 1; then
        log "Container ${DB_CONTAINER_NAME} is listening on ${DB_PORT}"
      else
        log "Container ${DB_CONTAINER_NAME} running but not listening on ${DB_PORT}; attempting restart"
        if ! sudo docker restart "${DB_CONTAINER_NAME}" >/dev/null 2>&1; then
          err "Failed to restart ${DB_CONTAINER_NAME}; attempting forced removal to allow recreate"
          if ! docker_force_remove "${DB_CONTAINER_NAME}"; then
            err "Failed to remove ${DB_CONTAINER_NAME}; printing diagnostics and aborting"
            print_diagnostics
            sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
            exit 6
          fi
        fi
      fi
    else
      log "${DB_CONTAINER_NAME} exists with status '${STATUS}' — attempting to start it"
      if ! docker_try_start "${DB_CONTAINER_NAME}"; then
        log "Starting ${DB_CONTAINER_NAME} failed; removing stale container to allow fresh create"
        if ! docker_force_remove "${DB_CONTAINER_NAME}"; then
          err "Failed to remove stale ${DB_CONTAINER_NAME}; printing diagnostics and aborting"
          print_diagnostics
          sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
          exit 7
        fi
      else
        log "Started existing container ${DB_CONTAINER_NAME}; giving it a moment to bind port"
        sleep 2
      fi
    fi
  else
    log "No container named ${DB_CONTAINER_NAME} exists locally"
  fi
else
  log "Docker not available; will attempt other DB start methods if present"
  CID=""
fi

# 6) DB not reachable and host port free — attempt to start DB container (compose preferred)
log "DB not reachable and host port free — attempting to start DB container (compose preferred)"
CID=${CID:-$(detect_db_cid || true)}
log "Using CID (if any): ${CID:-<none>}"

if [ -n "$CID" ]; then
  PROJECT=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project" }}' "$CID" 2>/dev/null || true)
  SERVICE_LABEL=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.service" }}' "$CID" 2>/dev/null || true)
  log "docker inspect labels: project='${PROJECT}' service='${SERVICE_LABEL}'"
  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && docker_available && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "Using docker compose for project ${PROJECT}, service ${SERVICE_LABEL}"
    if [ -d "/opt/demos-node/${PROJECT}" ]; then
      log "Running: (cd /opt/demos-node/${PROJECT} && sudo docker compose -p ${PROJECT} up -d ${SERVICE_LABEL})"
      (cd "/opt/demos-node/${PROJECT}" 2>/dev/null || true; sudo docker compose -p "$PROJECT" up -d "$SERVICE_LABEL") || sudo docker compose -p "$PROJECT" up -d || true
    else
      log "Running: sudo docker compose -p ${PROJECT} up -d ${SERVICE_LABEL}"
      sudo docker compose -p "$PROJECT" up -d "$SERVICE_LABEL" || sudo docker compose -p "$PROJECT" up -d || true
    fi
  else
    # try to start the container by ID if present, else try to start the named container
    if [ -n "$CID" ]; then
      log "Attempting to start container ID ${CID}"
      sudo docker update --restart=no "$CID" >/dev/null 2>&1 || true
      sudo docker start "$CID" >/dev/null 2>&1 || true
    else
      log "No CID found; attempting to start container named ${DB_CONTAINER_NAME} if present"
      if docker_available && docker_container_exists "${DB_CONTAINER_NAME}"; then
        sudo docker start "${DB_CONTAINER_NAME}" >/dev/null 2>&1 || true
      else
        if [ -d /opt/demos-node/postgres_5332 ] && docker_available && docker compose version >/dev/null 2>&1 2>/dev/null; then
          log "No running DB container found; using docker compose in /opt/demos-node/postgres_5332 to start DB"
          sudo bash -lc 'cd /opt/demos-node/postgres_5332 && docker compose up -d' || true
        else
          err "No DB container found and no compose project available to start DB. Printing diagnostics and aborting."
          print_diagnostics
          sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
          exit 3
        fi
      fi
    fi
  fi
else
  # no container currently publishing DB_PORT; try compose dir if present
  if [ -d /opt/demos-node/postgres_5332 ] && docker_available && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "No running DB container found; using docker compose in /opt/demos-node/postgres_5332 to start DB"
    sudo bash -lc 'cd /opt/demos-node/postgres_5332 && docker compose up -d' || true
  else
    err "No DB container found and no compose project available to start DB. Printing diagnostics and aborting."
    print_diagnostics
    sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
    exit 3
  fi
fi

# 7) Wait for DB to accept TCP connections
log "Waiting up to ${DB_WAIT}s for DB TCP on 127.0.0.1:${DB_PORT}"
if ! wait_tcp "${DB_PORT}" "${DB_WAIT}"; then
  err "DB did not become reachable within ${DB_WAIT}s. Printing diagnostics."
  print_diagnostics
  journalctl -u "${UNIT}" --no-pager -n 120 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 4
fi

# 8) DB reachable — wait a short moment and probe node HTTP /health again
log "DB reachable — giving node ${HTTP_WAIT}s to become healthy"
if ! http_probe "${HTTP_WAIT}"; then
  err "Node did not respond to HTTP /health after DB became reachable; printing diagnostics"
  print_diagnostics
  journalctl -u "${UNIT}" --no-pager -n 200 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 5
fi

# restore enablement to previous state
if [ "${PRE_ENABLED}" -eq 1 ]; then
  log "Restoring enablement: enabling ${UNIT}"
  sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
else
  log "Leaving ${UNIT} disabled (was disabled before)"
fi

log "Restart complete — node responsive"
exit 0
