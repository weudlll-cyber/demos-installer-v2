#!/bin/bash
# restart_demos_node
# - Mask the demos-node unit so systemd won't auto-restart while we operate
# - Stop the node unit if running
# - Detect and stop any Docker container publishing DB_PORT (attempt stop->rm)
# - If docker-proxy persists, attempt Docker daemon restart and last-resort pkill
# - Verify NODE_PORT and DB_PORT are free (or kill holders with --force)
# - Start the node unit and verify health
# - Restore systemd enablement/state and system postgres if changed
set -euo pipefail
IFS=$'\n\t'

SERVICE="demos-node"
UNIT="${SERVICE}.service"
ENV_FILE="/opt/demos-node/.env"

NODE_PORT=53550
DB_PORT=5332
FORCE=false
RETRY=3
SLEEP_BETWEEN=2
HEALTH_TIMEOUT=20
HEALTH_INTERVAL=2

# docker handling settings
DOCKER_RESTART_IF_PROXY_PERSISTS=true
DOCKER_PROXY_POLL_RETRIES=3
DOCKER_PROXY_POLL_SLEEP=1

for arg in "$@"; do
  case "$arg" in
    --force) FORCE=true ;;
    *) ;;
  esac
done

log(){ printf "\e[92m%s\e[0m\n" "$*"; }
err(){ printf "\e[91m%s\e[0m\n" "$*"; }

# load env overrides
if [ -f "$ENV_FILE" ]; then
  NODE_PORT=$(grep -m1 "^NODE_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$NODE_PORT")
  DB_PORT=$(grep -m1 "^DB_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$DB_PORT")
fi

ensure_systemd(){
  if ! command -v systemctl >/dev/null 2>&1; then
    err "systemctl not available; aborting"
    exit 1
  fi
}

is_listening(){ ss -tuln | grep -q ":${1} " && return 0 || return 1; }

kill_holders(){
  local port=$1
  if ! command -v lsof >/dev/null 2>&1; then
    err "lsof missing; cannot inspect port ${port}"
    return 1
  fi
  local pids
  pids=$(sudo lsof -ti :"${port}" 2>/dev/null || true)
  if [ -z "$pids" ]; then return 0; fi
  err "Port ${port} held by PID(s): ${pids}"
  if [ "$FORCE" = true ]; then
    err "Killing ${pids}"
    echo "$pids" | xargs -r sudo kill -9 || true
    sleep 1
    return 0
  fi
  return 1
}

wait_for_unit_active(){
  local unit=$1
  local waited=0
  while [ $waited -lt "$HEALTH_TIMEOUT" ]; do
    if systemctl is-active --quiet "$unit"; then return 0; fi
    sleep "$HEALTH_INTERVAL"
    waited=$((waited + HEALTH_INTERVAL))
  done
  return 1
}

tcp_probe(){
  local port=$1
  if command -v timeout >/dev/null 2>&1; then
    timeout 3 bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${port}" >/dev/null 2>&1 && return 0 || return 1
  else
    is_listening "$port" && return 0 || return 1
  fi
}

detect_docker_container_publishing_port(){
  # returns container id if docker is present and a container publishes the given host port
  local port=$1
  if ! command -v docker >/dev/null 2>&1; then
    return 1
  fi
  docker ps --format '{{.ID}}\t{{.Ports}}' | awk -v p=":${port}->" '$0 ~ p { print $1; exit }'
}

stop_and_rm_container(){
  local cid=$1
  if [ -z "$cid" ]; then return 1; fi
  log "ðŸ³ Stopping Docker container ${cid} that published port ${DB_PORT}..."
  sudo docker stop "${cid}" >/dev/null 2>&1 || true
  sleep 1
  log "ðŸ³ Removing container ${cid}..."
  sudo docker rm -f "${cid}" >/dev/null 2>&1 || true
  sleep 1
  return 0
}

attempt_clear_docker_proxy(){
  # try to ensure docker-proxy releases the host port
  local tries=0
  while [ $tries -lt $DOCKER_PROXY_POLL_RETRIES ]; do
    if ! is_listening "${DB_PORT}"; then
      return 0
    fi
    tries=$((tries+1))
    sleep "$DOCKER_PROXY_POLL_SLEEP"
  done

  # If still bound and docker present, restart docker daemon if allowed
  if command -v docker >/dev/null 2>&1 && [ "$DOCKER_RESTART_IF_PROXY_PERSISTS" = true ]; then
    log "ðŸ” docker-proxy still present for ${DB_PORT}; restarting docker daemon..."
    sudo systemctl restart docker || true
    sleep 2
    if ! is_listening "${DB_PORT}"; then
      return 0
    fi
  fi

  # last resort: attempt to pkill docker-proxy processes bound to the port (risky)
  if command -v pgrep >/dev/null 2>&1; then
    local dpids
    dpids=$(pgrep -f "docker-proxy.*:${DB_PORT}" || true)
    if [ -n "$dpids" ]; then
      log "âš  Found docker-proxy PID(s) ${dpids}; killing them as last resort..."
      echo "$dpids" | xargs -r sudo kill -9 || true
      sleep 1
      sudo systemctl restart docker || true
      sleep 2
      if ! is_listening "${DB_PORT}"; then
        return 0
      fi
    fi
  fi

  return 1
}

# MAIN
ensure_systemd

if ! systemctl list-unit-files --type=service --all | grep -q "^${UNIT}"; then
  err "Unit ${UNIT} not present; aborting"
  exit 1
fi

log "1) Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true

log "2) Stop the node unit if active"
if systemctl is-active --quiet "${UNIT}"; then
  sudo systemctl stop "${UNIT}" || true
  sleep 1
  log "Stopped ${UNIT}"
else
  log "${UNIT} not active"
fi

log "3) Ensure NODE_PORT=${NODE_PORT} is free"
if is_listening "${NODE_PORT}"; then
  err "Node port ${NODE_PORT} still in use"
  if [ "$FORCE" = true ]; then
    kill_holders "${NODE_PORT}" || { err "Could not kill node port holders"; sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true; exit 1; }
    log "Node port freed via --force"
  else
    err "Rerun with --force to kill holders or free manually"
    sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
    exit 1
  fi
else
  log "Node port free"
fi

log "4) Ensure DB_PORT=${DB_PORT} is free (detecting Docker containers)"

# 4a) If a docker container publishes DB_PORT, stop & rm it (safe attempt)
CID=$(detect_docker_container_publishing_port "${DB_PORT}" || true)
if [ -n "${CID}" ]; then
  log "Detected Docker container ${CID} publishing host port ${DB_PORT}"
  stop_and_rm_container "${CID}" || true
  # give docker-proxy a moment and attempt to clear
  if attempt_clear_docker_proxy; then
    log "DB port ${DB_PORT} freed after container stop/docker restart."
  else
    err "DB port ${DB_PORT} still in use after stopping container."
    if [ "$FORCE" = true ]; then
      err "Force: will attempt killing remaining holders."
      kill_holders "${DB_PORT}" || { err "Could not kill DB port holders"; sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true; exit 1; }
    else
      err "Rerun with --force to kill holders or free manually"
      sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
      exit 1
    fi
  fi
else
  # 4b) No docker container detected; try to stop system postgresql if present, then fall back to --force
  if systemctl list-unit-files --type=service --all | grep -q '^postgresql'; then
    if systemctl is-active --quiet postgresql; then
      log "Stopping system postgresql to avoid it binding DB_PORT"
      sudo systemctl stop postgresql >/dev/null 2>&1 || true
      sleep 1
    fi
  fi

  if is_listening "${DB_PORT}"; then
    err "DB port ${DB_PORT} still in use"
    if [ "$FORCE" = true ]; then
      kill_holders "${DB_PORT}" || { err "Could not kill DB port holders"; sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true; exit 1; }
      log "DB port freed via --force"
    else
      err "Rerun with --force to kill holders or free manually"
      sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
      exit 1
    fi
  else
    log "DB port free"
  fi
fi

log "5) Start the node unit (unmasking temporarily to allow management)"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
sudo systemctl start "${UNIT}" || { err "systemd start failed"; sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true; exit 1; }

log "Waiting for ${UNIT} to become active and responsive"
if ! wait_for_unit_active "${UNIT}"; then
  err "${UNIT} did not become active within timeout"
  journalctl -u "${UNIT}" --no-pager -n 120 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

if ! tcp_probe "${NODE_PORT}"; then
  err "Node not responding on TCP port ${NODE_PORT} after start"
  journalctl -u "${UNIT}" --no-pager -n 120 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "Node started and responsive on ${NODE_PORT}"

log "6) Restore systemd enablement/state for ${UNIT}"
if [ "${PRE_ENABLED}" -eq 1 ]; then
  log "Re-enabling and ensuring ${UNIT} is active under systemd"
  sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
else
  log "Leaving ${UNIT} disabled but unmasked"
  sudo systemctl disable "${UNIT}" >/dev/null 2>&1 || true
fi

# Ensure system postgresql restored (best-effort)
if systemctl list-unit-files --type=service --all | grep -q '^postgresql'; then
  sudo systemctl enable --now postgresql >/dev/null 2>&1 || true
fi

log "Restart procedure complete"
exit 0
