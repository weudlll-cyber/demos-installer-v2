#!/bin/bash
# restart_demos_node
# - Temporarily disable Docker container restart policy for DB container that publishes DB_PORT
# - Stop that container (only if running)
# - Mask demos-node unit so systemd won't autorestart while we operate
# - Stop node unit, verify ports free, start node, verify health
# - Restore Docker container restart policy and start container again if it was running before
set -euo pipefail
IFS=$'\n\t'

SERVICE="demos-node"
UNIT="${SERVICE}.service"
ENV_FILE="/opt/demos-node/.env"

NODE_PORT=53550
DB_PORT=5332
FORCE=false
RETRY=3
SLEEP_BETWEEN=2
HEALTH_TIMEOUT=20
HEALTH_INTERVAL=2
STATE_DIR="/var/run"
DB_STATE_FILE="${STATE_DIR}/demos-node-db-was-running"
DB_POLICY_FILE="${STATE_DIR}/demos-node-db-restart-policy"

for arg in "$@"; do
  case "$arg" in
    --force) FORCE=true ;;
    *) ;;
  esac
done

log(){ printf "\e[92m%s\e[0m\n" "$*"; }
err(){ printf "\e[91m%s\e[0m\n" "$*" >&2; }

# load env overrides
if [ -f "$ENV_FILE" ]; then
  NODE_PORT=$(grep -m1 "^NODE_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$NODE_PORT")
  DB_PORT=$(grep -m1 "^DB_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$DB_PORT")
fi

ensure_systemd(){
  if ! command -v systemctl >/dev/null 2>&1; then
    err "systemctl not available; aborting"
    exit 1
  fi
}

is_listening(){ ss -tuln | grep -q ":${1} " && return 0 || return 1; }

wait_for_unit_active(){
  local unit=$1 waited=0
  while [ $waited -lt "$HEALTH_TIMEOUT" ]; do
    if systemctl is-active --quiet "$unit"; then return 0; fi
    sleep "$HEALTH_INTERVAL"
    waited=$((waited + HEALTH_INTERVAL))
  done
  return 1
}

tcp_probe(){
  local port=$1
  if command -v timeout >/dev/null 2>&1; then
    timeout 3 bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${port}" >/dev/null 2>&1 && return 0 || return 1
  else
    is_listening "$port" && return 0 || return 1
  fi
}

detect_docker_container_publishing_port(){
  local port=$1
  if ! command -v docker >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  docker ps --format '{{.ID}}\t{{.Ports}}' | awk -v p=":${port}->" '$0 ~ p { print $1; exit }'
}

record_db_state(){
  local cid=$1
  mkdir -p "$STATE_DIR"
  if [ -n "$cid" ]; then
    echo "$cid" > "$DB_STATE_FILE"
  else
    rm -f "$DB_STATE_FILE" || true
  fi
}

record_policy(){
  local cid=$1
  if [ -z "$cid" ]; then
    rm -f "$DB_POLICY_FILE" || true
    return 0
  fi
  local pol
  pol=$(docker inspect --format '{{.HostConfig.RestartPolicy.Name}}' "$cid" 2>/dev/null || true)
  # write whatever we got (may be empty -> treated as "no")
  echo "${pol:-no}" > "$DB_POLICY_FILE"
}

restore_policy_and_start(){
  if [ ! -f "$DB_STATE_FILE" ]; then
    return 0
  fi
  local cid
  cid=$(cat "$DB_STATE_FILE" 2>/dev/null || true)
  [ -z "$cid" ] && rm -f "$DB_STATE_FILE" "$DB_POLICY_FILE" || true && return 0
  if ! command -v docker >/dev/null 2>&1; then
    err "docker not present; cannot restore container ${cid}"
    return 0
  fi

  # restore restart policy if recorded
  if [ -f "$DB_POLICY_FILE" ]; then
    local oldpol
    oldpol=$(cat "$DB_POLICY_FILE" || echo "no")
    # if container exists, attempt to restore its policy
    if docker inspect "$cid" >/dev/null 2>&1; then
      log "Restoring restart policy '${oldpol}' for container ${cid}"
      sudo docker update --restart="${oldpol}" "$cid" >/dev/null 2>&1 || true
      # start the container if it is not running and was previously recorded as running
      if ! docker inspect -f '{{.State.Running}}' "$cid" 2>/dev/null | grep -q 'true'; then
        log "Starting container ${cid}"
        sudo docker start "$cid" >/dev/null 2>&1 || true
      fi
    else
      err "Previously recorded container ${cid} not found; skipping restore"
    fi
  fi

  # cleanup state files
  rm -f "$DB_STATE_FILE" "$DB_POLICY_FILE" || true
}

# MAIN
ensure_systemd

if ! systemctl list-unit-files --type=service --all | grep -q "^${UNIT}"; then
  err "Unit ${UNIT} not present; aborting"
  exit 1
fi

# 1) Mask node unit to prevent systemd from auto-restarting while we operate
log "1) Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true

# 2) Detect docker container publishing DB port; if found, record policy and disable restart then stop it
CID=$(detect_docker_container_publishing_port "${DB_PORT}" || true)
if [ -n "${CID}" ]; then
  log "Detected Docker container ${CID} publishing host port ${DB_PORT}"
  # record current restart policy and container id
  record_policy "$CID"
  record_db_state "$CID"
  local OLD_POLICY
  OLD_POLICY=$(cat "$DB_POLICY_FILE" 2>/dev/null || echo "no")
  log "Recorded restart policy '${OLD_POLICY}' for container ${CID}"
  # temporarily disable automatic restarts to avoid immediate rebinding
  if [ "$OLD_POLICY" != "no" ]; then
    log "Temporarily disabling restart policy for ${CID}"
    sudo docker update --restart=no "$CID" >/dev/null 2>&1 || true
  fi
  # stop the container gracefully
  log "Stopping Docker container ${CID}"
  sudo docker stop --time 10 "$CID" >/dev/null 2>&1 || {
    err "docker stop failed for ${CID}; proceeding but container may still bind port"
  }
  sleep 1
  # give docker-proxy a moment and try to clear; if docker proxy persists we'll handle later
  sleep 1
fi

# 3) Stop node unit if active
log "2) Stop the node unit if active"
if systemctl is-active --quiet "${UNIT}"; then
  sudo systemctl stop "${UNIT}" || true
  sleep 1
  log "Stopped ${UNIT}"
else
  log "${UNIT} not active"
fi

# 4) Ensure NODE_PORT is free
log "3) Ensure NODE_PORT=${NODE_PORT} is free"
if is_listening "${NODE_PORT}"; then
  err "Node port ${NODE_PORT} still in use"
  if [ "$FORCE" = true ]; then
    err "Force: killing holders"
    sudo lsof -ti :"${NODE_PORT}" | xargs -r sudo kill -9 || true
  else
    err "Rerun with --force to kill holders or free manually; restoring DB policy and unmasking unit"
    restore_policy_and_start
    sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
    exit 1
  fi
else
  log "Node port free"
fi

# 5) Ensure DB_PORT is free (if still bound, either try gentle clearance or fail)
log "4) Ensure DB_PORT=${DB_PORT} is free"
if is_listening "${DB_PORT}"; then
  err "DB port ${DB_PORT} still in use after stopping container"
  if [ "$FORCE" = true ]; then
    err "Force: killing holders"
    sudo lsof -ti :"${DB_PORT}" | xargs -r sudo kill -9 || true
    sleep 1
  else
    err "Rerun with --force to kill holders or free manually; restoring DB policy and unmasking unit"
    restore_policy_and_start
    sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
    exit 1
  fi
else
  log "DB port free"
fi

# 6) Start node unit (unmask temporarily to allow management)
log "5) Start node unit (unmasking temporarily to allow management)"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
sudo systemctl start "${UNIT}" || {
  err "systemd start failed; attempting to restore DB policy and re-mask unit"
  restore_policy_and_start
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
}

# wait for active and tcp health
log "Waiting for ${UNIT} to become active and responsive"
if ! wait_for_unit_active "${UNIT}"; then
  err "${UNIT} did not become active within timeout; restoring DB policy and re-masking"
  journalctl -u "${UNIT}" --no-pager -n 160 || true
  restore_policy_and_start
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

if ! tcp_probe "${NODE_PORT}"; then
  err "Node not responding on TCP port ${NODE_PORT} after start; restoring DB policy and re-masking"
  journalctl -u "${UNIT}" --no-pager -n 160 || true
  restore_policy_and_start
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "Node started and responsive on ${NODE_PORT}"

# 7) Restore Docker container restart policy and start container again if it was recorded
log "6) Restoring DB container restart policy and starting container if needed (best-effort)"
restore_policy_and_start

# 8) Restore systemd enablement/state for node
log "7) Restore systemd enablement/state for ${UNIT}"
if [ "${PRE_ENABLED}" -eq 1 ]; then
  log "Re-enabling and ensuring ${UNIT} is active under systemd"
  sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
else
  log "Leaving ${UNIT} disabled but unmasked"
  sudo systemctl disable "${UNIT}" >/dev/null 2>&1 || true
fi

log "Restart procedure complete"
exit 0
