#!/bin/bash
# restart_demos_node (simplified, safe)
# - Stop DB container (prefer docker compose stop when available) without persisting state
# - Disable container restart before stopping to reduce race
# - Start DB (compose or container), wait for DB to be reachable
# - Start demos-node systemd unit only after DB is reachable
set -euo pipefail
IFS=$'\n\t'

SERVICE="demos-node"
UNIT="${SERVICE}.service"
ENV_FILE="/opt/demos-node/.env"

NODE_PORT=53550
DB_PORT=5332
FORCE=false
HEALTH_TIMEOUT=30
HEALTH_INTERVAL=2

for arg in "$@"; do
  case "$arg" in
    --force) FORCE=true ;;
    *) ;;
  esac
done

log(){ printf "\e[92m%s\e[0m\n" "$*"; }
err(){ printf "\e[91m%s\e[0m\n" "$*" >&2; }

# load env overrides
if [ -f "$ENV_FILE" ]; then
  NODE_PORT=$(grep -m1 "^NODE_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$NODE_PORT")
  DB_PORT=$(grep -m1 "^DB_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$DB_PORT")
fi

is_listening(){ ss -tuln | grep -q ":${1} " && return 0 || return 1; }

wait_for_unit_active(){
  unit=$1
  waited=0
  while [ $waited -lt "$HEALTH_TIMEOUT" ]; do
    if systemctl is-active --quiet "$unit"; then return 0; fi
    sleep "$HEALTH_INTERVAL"
    waited=$((waited + HEALTH_INTERVAL))
  done
  return 1
}

tcp_probe_once(){
  port=$1
  bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${port}" >/dev/null 2>&1 && return 0 || return 1
}

detect_docker_container_publishing_port(){
  port=$1
  if ! command -v docker >/dev/null 2>&1; then
    echo ""
    return 0
  fi
  docker ps --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' | awk -v p=":${port}->" '$0 ~ p { print $1; exit }'
}

wait_for_db(){
  timeout=$HEALTH_TIMEOUT
  elapsed=0
  interval=1

  # if docker present and container publishing port exists, prefer checking Docker health
  if command -v docker >/dev/null 2>&1; then
    cid=$(docker ps --format '{{.ID}}\t{{.Ports}}' | awk -v p=":${DB_PORT}->" '$0 ~ p { print $1; exit }' || true)
    if [ -n "$cid" ]; then
      # docker health check if present
      if docker inspect -f '{{.State.Health.Status}}' "$cid" >/dev/null 2>&1; then
        while [ $elapsed -lt $timeout ]; do
          state=$(docker inspect -f '{{.State.Health.Status}}' "$cid" 2>/dev/null || echo "")
          if [ "$state" = "healthy" ]; then
            log "DB container ${cid} reports healthy"
            return 0
          fi
          sleep $interval
          elapsed=$((elapsed + interval))
        done
      fi
    fi
  fi

  # fallback to TCP probe on localhost
  elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if tcp_probe_once "$DB_PORT"; then
      log "DB listening on 127.0.0.1:${DB_PORT}"
      return 0
    fi
    sleep $interval
    elapsed=$((elapsed + interval))
  done

  err "DB did not become reachable on 127.0.0.1:${DB_PORT} within ${timeout}s"
  return 1
}

ensure_systemd(){
  if ! command -v systemctl >/dev/null 2>&1; then
    err "systemctl not available; aborting"
    exit 1
  fi
}

# BEGIN
ensure_systemd

if ! systemctl list-unit-files --type=service --all | grep -q "^${UNIT}"; then
  err "Unit ${UNIT} not present; aborting"
  exit 1
fi

log "1) Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true

# detect container publishing DB_PORT
CID=$(detect_docker_container_publishing_port "${DB_PORT}" || true)
if [ -n "${CID}" ]; then
  log "Detected container ${CID} publishing host port ${DB_PORT}"

  # detect compose labels
  PROJECT=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project" }}' "${CID}" 2>/dev/null || true)
  SERVICE_LABEL=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.service" }}' "${CID}" 2>/dev/null || true)

  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "Stopping compose service ${SERVICE_LABEL} in project ${PROJECT}"
    sudo docker compose -p "${PROJECT}" stop "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  elif [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker-compose >/dev/null 2>&1; then
    log "Stopping compose service ${SERVICE_LABEL} in project ${PROJECT} (docker-compose)"
    sudo docker-compose -p "${PROJECT}" stop "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  else
    log "Disabling container restart and stopping container ${CID}"
    sudo docker update --restart=no "${CID}" >/dev/null 2>&1 || true
    sudo docker stop --time 10 "${CID}" >/dev/null 2>&1 || {
      err "docker stop failed for ${CID}; proceeding but container may still bind port"
    }
  fi
  sleep 1
else
  log "No DB container found publishing port ${DB_PORT}"
fi

# Start DB back (if compose-managed prefer compose start, else start container if exists)
if [ -n "${CID}" ]; then
  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "Starting compose service ${SERVICE_LABEL} in project ${PROJECT}"
    sudo docker compose -p "${PROJECT}" start "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  elif [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker-compose >/dev/null 2>&1; then
    log "Starting compose service ${SERVICE_LABEL} in project ${PROJECT} (docker-compose)"
    sudo docker-compose -p "${PROJECT}" start "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  else
    # try to start the same container id if it still exists; otherwise rely on docker to recreate it
    if docker inspect "${CID}" >/dev/null 2>&1; then
      log "Starting container ${CID}"
      sudo docker start "${CID}" >/dev/null 2>&1 || true
    else
      log "Container ${CID} not present after stop; relying on Docker/compose to recreate it"
    fi
  fi
fi

log "2) Wait for DB to be reachable before starting node"
if ! wait_for_db; then
  err "DB unreachable; unmasking unit and aborting"
  sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "3) Start node unit (unmasking temporarily to allow management)"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
sudo systemctl start "${UNIT}" || {
  err "systemd start failed; re-masking unit and aborting"
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
}

log "Waiting for ${UNIT} to become active and responsive"
if ! wait_for_unit_active "${UNIT}"; then
  err "${UNIT} did not become active within timeout; re-masking and aborting"
  journalctl -u "${UNIT}" --no-pager -n 160 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

if ! tcp_probe_once "${NODE_PORT}"; then
  err "Node not responding on TCP port ${NODE_PORT} after start; re-masking and aborting"
  journalctl -u "${UNIT}" --no-pager -n 160 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "Node started and responsive on ${NODE_PORT}"
log "Note: simplified helper does not persist previous container restart policy"
log "4) Restore systemd enablement/state for ${UNIT}"
if [ "${PRE_ENABLED}" -eq 1 ]; then
  log "Re-enabling and ensuring ${UNIT} is active under systemd"
  sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
else
  log "Leaving ${UNIT} disabled but unmasked"
  sudo systemctl disable "${UNIT}" >/dev/null 2>&1 || true
fi

log "Restart procedure complete"
exit 0
