#!/bin/bash
# restart_demos_node (patched)
# - Prefer docker-compose stop/start when available
# - Normalize EXPOSED_URL/EXPOSED_IP from .env
# - Wait for DB to be reachable
# - Start demos-node only after HTTP /health probe succeeds (tries loopback + exposed)
set -euo pipefail
IFS=$'\n\t'

SERVICE="demos-node"
UNIT="${SERVICE}.service"
ENV_FILE="/opt/demos-node/.env"

NODE_PORT=53550
DB_PORT=5332
FORCE=false
HEALTH_TIMEOUT=90   # overall wait for readiness
DB_TIMEOUT=30
DB_POLL_INTERVAL=1
HTTP_POLL_INTERVAL=1

for arg in "$@"; do
  case "$arg" in
    --force) FORCE=true ;;
    *) ;;
  esac
done

log(){ printf "\e[92m%s\e[0m\n" "$*"; }
err(){ printf "\e[91m%s\e[0m\n" "$*" >&2; }

_trim_trailing() {
  local s="$1"
  s="${s%/}"
  s="${s%:}"
  s="$(printf "%s" "$s" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
  printf '%s' "$s"
}

# load env overrides and normalize exposed URL/IP
BASE_URL="http://127.0.0.1:$NODE_PORT"
if [ -f "$ENV_FILE" ]; then
  NODE_PORT=$(grep -m1 "^NODE_PORT=" "$ENV_FILE" | cut -d'=' -f2 || echo "$NODE_PORT")
  NODE_PORT=${NODE_PORT:-$NODE_PORT}
  EXPOSED_URL=$(grep -m1 "^EXPOSED_URL=" "$ENV_FILE" | cut -d'=' -f2 || true)
  EXPOSED_IP=$(grep -m1 "^EXPOSED_IP=" "$ENV_FILE" | cut -d'=' -f2 || true)
  EXPOSED_URL=${EXPOSED_URL:-}
  EXPOSED_IP=${EXPOSED_IP:-}

  if [ -n "$EXPOSED_URL" ]; then
    if [[ "$EXPOSED_URL" != http://* && "$EXPOSED_URL" != https://* ]]; then
      EXPOSED_URL="http://$EXPOSED_URL"
    fi
    base="$(_trim_trailing "$EXPOSED_URL")"
    hostport="${base#http://}"
    hostport="${hostport#https://}"
    if [[ "$hostport" =~ :[0-9]+$ ]]; then
      BASE_URL="$base"
    else
      BASE_URL="${base}:$NODE_PORT"
    fi
  elif [ -n "$EXPOSED_IP" ]; then
    ip="$(_trim_trailing "$EXPOSED_IP")"
    if [[ "$ip" == *:* ]]; then
      BASE_URL="http://[$ip]:$NODE_PORT"
    else
      BASE_URL="http://$ip:$NODE_PORT"
    fi
  else
    BASE_URL="http://127.0.0.1:$NODE_PORT"
  fi
fi
BASE_URL="${BASE_URL%/}"
HTTP_ENDPOINT="${BASE_URL}/health"

# helpers
ensure_systemd(){
  if ! command -v systemctl >/dev/null 2>&1; then
    err "systemctl not available; aborting"
    exit 1
  fi
}

detect_docker_container_publishing_port(){
  local port=$1
  if ! command -v docker >/dev/null 2>&1; then echo ""; return 0; fi
  docker ps --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' | awk -v p=":${port}->" '$0 ~ p { print $1; exit }'
}

wait_for_db_tcp(){
  local timeout=${1:-$DB_TIMEOUT}
  local elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${DB_PORT}" >/dev/null 2>&1; then
      log "DB listening on 127.0.0.1:${DB_PORT}"
      return 0
    fi
    sleep $DB_POLL_INTERVAL
    elapsed=$((elapsed + DB_POLL_INTERVAL))
  done
  return 1
}

try_http_probe(){
  local timeout=${1:-$HEALTH_TIMEOUT}
  local elapsed=0
  local addrs="$HTTP_ENDPOINT http://127.0.0.1:${NODE_PORT}/health"
  # also try raw advertised host without trailing path if BASE_URL contained host only
  while [ $elapsed -lt $timeout ]; do
    for u in $addrs; do
      if curl -fsS -m 3 "$u" >/dev/null 2>&1; then
        log "HTTP probe ok $u"
        return 0
      fi
    done
    sleep $HTTP_POLL_INTERVAL
    elapsed=$((elapsed + HTTP_POLL_INTERVAL))
  done
  return 1
}

restore_unit_state(){
  # leave enabled/disabled as before; attempt to re-enable if it was enabled before
  if [ "${PRE_ENABLED:-0}" -eq 1 ]; then
    sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
  else
    sudo systemctl disable "${UNIT}" >/dev/null 2>&1 || true
  fi
}

# MAIN
ensure_systemd

if ! systemctl list-unit-files --type=service --all | grep -q "^${UNIT}"; then
  err "Unit ${UNIT} not present; aborting"
  exit 1
fi

log "1) Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true

CID=$(detect_docker_container_publishing_port "${DB_PORT}" || true)
PROJECT=""
SERVICE_LABEL=""

if [ -n "$CID" ]; then
  log "Detected Docker container ${CID} publishing host port ${DB_PORT}"
  PROJECT=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project" }}' "${CID}" 2>/dev/null || true)
  SERVICE_LABEL=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.service" }}' "${CID}" 2>/dev/null || true)

  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "Stopping compose service ${SERVICE_LABEL} in project ${PROJECT}"
    sudo docker compose -p "${PROJECT}" stop "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  elif [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker-compose >/dev/null 2>&1; then
    log "Stopping compose service ${SERVICE_LABEL} in project ${PROJECT} (docker-compose)"
    sudo docker-compose -p "${PROJECT}" stop "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  else
    log "Disabling container restart and stopping container ${CID}"
    sudo docker update --restart=no "${CID}" >/dev/null 2>&1 || true
    sudo docker stop --time 10 "${CID}" >/dev/null 2>&1 || {
      err "docker stop failed for ${CID}; proceeding but container may still bind port"
    }
  fi
  sleep 1
else
  log "No DB container found publishing port ${DB_PORT}"
fi

# start DB back (compose preferred)
if [ -n "${CID}" ]; then
  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 2>/dev/null; then
    log "Starting compose service ${SERVICE_LABEL} in project ${PROJECT}"
    sudo docker compose -p "${PROJECT}" start "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  elif [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker-compose >/dev/null 2>&1; then
    log "Starting compose service ${SERVICE_LABEL} in project ${PROJECT} (docker-compose)"
    sudo docker-compose -p "${PROJECT}" start "${SERVICE_LABEL}" >/dev/null 2>&1 || true
  else
    if command -v docker >/dev/null 2>&1 && docker inspect "${CID}" >/dev/null 2>&1; then
      log "Starting container ${CID}"
      sudo docker start "${CID}" >/dev/null 2>&1 || true
    else
      log "Container ${CID} not present after stop; relying on Docker/compose to recreate it"
    fi
  fi
fi

log "2) Wait for DB to be reachable (TCP) before starting node"
if ! wait_for_db_tcp $DB_TIMEOUT; then
  err "DB did not become reachable on ${DB_PORT} within ${DB_TIMEOUT}s"
  if [ "$FORCE" = true ]; then
    err "Force: killing holders on ${DB_PORT}"
    sudo lsof -ti :"${DB_PORT}" | xargs -r sudo kill -9 || true
    sleep 1
    if ! wait_for_db_tcp $DB_TIMEOUT; then
      err "DB still unreachable after force; aborting"
      sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
      exit 1
    fi
  else
    sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
    exit 1
  fi
fi

log "3) Start node unit (unmasking temporarily to allow management)"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
sudo systemctl start "${UNIT}" || {
  err "systemd start failed; re-masking unit and aborting"
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
}

log "Waiting for ${UNIT} to become active (systemd)"
waited=0
while [ $waited -lt $HEALTH_TIMEOUT ]; do
  if systemctl is-active --quiet "${UNIT}"; then break; fi
  sleep 1
  waited=$((waited+1))
done
if ! systemctl is-active --quiet "${UNIT}"; then
  err "${UNIT} did not become active within ${HEALTH_TIMEOUT}s; re-masking and aborting"
  journalctl -u "${UNIT}" --no-pager -n 120 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "4) Wait for HTTP /health to respond (this may take a while)"
if ! try_http_probe 60; then
  err "Node HTTP /health did not respond within probe timeout"
  journalctl -u "${UNIT}" --no-pager -n 200 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "Node started and responsive on ${NODE_PORT}"

log "5) Restore systemd enablement/state for ${UNIT}"
restore_unit_state

log "Restart procedure complete"
exit 0
