#!/bin/bash
# restart_demos_node — compact, safe restart flow with explanatory comments
# - Mask unit to avoid flapping
# - Stop DB (compose if available, else stop container)
# - Start DB and wait for local TCP readiness
# - Unmask+start systemd unit and wait for HTTP /health
# - Restore unit enablement state
set -euo pipefail
IFS=$'\n\t'

UNIT="demos-node.service"
ENV="/opt/demos-node/.env"
NODE_PORT=53550
DB_PORT=5332
DB_WAIT=30    # seconds to wait for DB TCP
HTTP_WAIT=60  # seconds to wait for HTTP /health

# small helpers
log(){ printf "[+] %s\n" "$*"; }
err(){ printf "[!] %s\n" "$*" >&2; }

# read NODE_PORT override if present
if [ -f "$ENV" ]; then
  p=$(grep -m1 '^NODE_PORT=' "$ENV" | cut -d= -f2 || true)
  [ -n "$p" ] && NODE_PORT="$p"
fi

# prefer docker-compose stop/start when we can detect the DB container publishing DB_PORT
detect_db_cid(){
  command -v docker >/dev/null 2>&1 || return 0
  docker ps --format '{{.ID}}\t{{.Ports}}' | awk -v p=":${DB_PORT}->" '$0 ~ p { print $1; exit }'
}

wait_tcp(){
  # wait for 127.0.0.1:$1 to accept TCP connections up to $2 seconds
  local port=$1 timeout=${2:-10} elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if bash -c "cat < /dev/null > /dev/tcp/127.0.0.1/${port}" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1; elapsed=$((elapsed+1))
  done
  return 1
}

http_probe(){
  # probe loopback and return 0 on success
  local timeout=${1:-30} elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if curl -fsS -m 3 "http://127.0.0.1:${NODE_PORT}/health" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1; elapsed=$((elapsed+1))
  done
  return 1
}

# BEGIN restart flow
log "Masking ${UNIT} to prevent automatic restarts while we operate"
PRE_ENABLED=0
if systemctl is-enabled --quiet "${UNIT}" 2>/dev/null; then PRE_ENABLED=1; fi
sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true

CID=$(detect_db_cid || true)
if [ -n "$CID" ]; then
  log "Found DB container ${CID} publishing ${DB_PORT}; attempting compose stop if available"
  PROJECT=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.project" }}' "$CID" 2>/dev/null || true)
  SERVICE_LABEL=$(docker inspect --format '{{ index .Config.Labels "com.docker.compose.service" }}' "$CID" 2>/dev/null || true)
  if [ -n "$PROJECT" ] && [ -n "$SERVICE_LABEL" ] && command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 2>/dev/null; then
    sudo docker compose -p "$PROJECT" stop "$SERVICE_LABEL" || true
    sudo docker compose -p "$PROJECT" start "$SERVICE_LABEL" || true
  else
    # fallback: disable restart and stop container, then try start
    sudo docker update --restart=no "$CID" >/dev/null 2>&1 || true
    sudo docker stop --time 10 "$CID" >/dev/null 2>&1 || true
    sudo docker start "$CID" >/dev/null 2>&1 || true
  fi
else
  log "No DB container publishing port ${DB_PORT} detected; skipping container ops"
fi

log "Waiting up to ${DB_WAIT}s for DB TCP on 127.0.0.1:${DB_PORT}"
if ! wait_tcp "${DB_PORT}" "${DB_WAIT}"; then
  err "DB not reachable on ${DB_PORT}; aborting and unmasking unit"
  sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

log "Unmasking and starting ${UNIT}"
sudo systemctl unmask "${UNIT}" >/dev/null 2>&1 || true
sudo systemctl daemon-reload >/dev/null 2>&1 || true
sudo systemctl start "${UNIT}" || {
  err "systemctl start failed; re-masking and aborting"
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
}

log "Waiting for HTTP /health on port ${NODE_PORT} up to ${HTTP_WAIT}s"
if ! http_probe "${HTTP_WAIT}"; then
  err "Node did not respond to HTTP /health in time; re-masking unit"
  journalctl -u "${UNIT}" --no-pager -n 120 || true
  sudo systemctl mask "${UNIT}" >/dev/null 2>&1 || true
  exit 1
fi

# restore enablement to previous state
if [ "${PRE_ENABLED}" -eq 1 ]; then
  log "Restoring enablement: enabling ${UNIT}"
  sudo systemctl enable --now "${UNIT}" >/dev/null 2>&1 || true
else
  log "Leaving ${UNIT} disabled (was disabled before)"
fi

log "Restart complete — node responsive"
exit 0exit 0
